/*
 * Copyright (c) 2024 ModCore Inc. All rights reserved.
 *
 * This code is part of ModCore Inc.'s Essential Mod repository and is protected
 * under copyright registration # TX0009138511. For the full license, see:
 * https://github.com/EssentialGG/Essential/blob/main/LICENSE
 *
 * You may not use, copy, reproduce, modify, sell, license, distribute,
 * commercialize, or otherwise exploit, or create derivative works based
 * upon, this file or any other in this repository, all of which is reserved by Essential.
 */
package gg.essential.gui.common

import gg.essential.elementa.UIComponent
import gg.essential.elementa.components.image.ImageProvider
import gg.essential.universal.UMatrixStack
import gg.essential.universal.UResolution
import gg.essential.util.GlFrameBuffer
import org.lwjgl.opengl.GL11.*
import java.awt.Color

/**
 * Component which displays a frame buffer texture.
 *
 * The frame buffer is generated by a call to its [render] method, and regenerated only when its size changes or
 * [markDirty] is called.
 *
 * The frame buffer must be clean up by a call to [delete] when the component is to be discarded.
 */
abstract class UIFrameBuffer : UIComponent(), ImageProvider {
    private var dirty = true
    private val frameBuffer = GlFrameBuffer(0, 0)

    fun markDirty() {
        dirty = true
    }

    open fun delete() {
        frameBuffer.delete()
    }

    override fun draw(matrixStack: UMatrixStack) {
        beforeDraw(matrixStack)

        val x = getLeft().toDouble()
        val y = getTop().toDouble()
        val width = getWidth().toDouble()
        val height = getHeight().toDouble()
        val color = getColor()
        drawImage(matrixStack, x, y, width, height, color)

        super.draw(matrixStack)
    }

    fun drawFrameBuffer(width: Double, height: Double) {
        // If windowWidth is 0, we get a divide by 0 exception on osScale
        // If the height is zero, its probably safe not to render anyway.
        if (UResolution.windowWidth == 0 || UResolution.windowHeight == 0) {
            return
        }
        val mcScale = UResolution.scaleFactor.toFloat()
        val realWidth = width.toFloat() * mcScale
        val realHeight = height.toFloat() * mcScale
        val frameWidth = realWidth.toInt()
        val frameHeight = realHeight.toInt()

        if (frameWidth != frameBuffer.width || frameHeight != frameBuffer.height) {
            frameBuffer.resize(frameWidth, frameHeight)
            dirty = true
        }

        if (dirty) {
            dirty = false // reset this before rendering, so the renderVG method can re-set it

            frameBuffer.clear()
            frameBuffer.useAsRenderTarget { stack, _, _ ->
                render(stack, realWidth, realHeight)
            }
        }
    }

    override fun drawImage(matrixStack: UMatrixStack, x: Double, y: Double, width: Double, height: Double, color: Color) {
        drawFrameBuffer(width, height)

        frameBuffer.drawTexture(matrixStack, x, y, width, height, color)
    }

    /**
     * Renders the desired content into the frame buffer.
     *
     * The given width/height is the size of this component in real pixels (not including MC scaling).
     *
     * The given matrix stack has been adjusted such that 0/0 is the very top left of the frame buffer and width/height
     * is the very bottom right fo the frame buffer (same as MC's GUI coordinates but restricted to only the frame
     * buffer and without MC's scaling).
     */
    protected abstract fun render(matrixStack: UMatrixStack, width: Float, height: Float)
}

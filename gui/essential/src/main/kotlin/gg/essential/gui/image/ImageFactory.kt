/*
 * Copyright (c) 2024 ModCore Inc. All rights reserved.
 *
 * This code is part of ModCore Inc.'s Essential Mod repository and is protected
 * under copyright registration # TX0009138511. For the full license, see:
 * https://github.com/EssentialGG/Essential/blob/main/LICENSE
 *
 * You may not use, copy, reproduce, modify, sell, license, distribute,
 * commercialize, or otherwise exploit, or create derivative works based
 * upon, this file or any other in this repository, all of which is reserved by Essential.
 */
package gg.essential.gui.image

import gg.essential.elementa.components.UIImage
import gg.essential.gui.common.AutoImageSize
import java.awt.Color

/**
 * Stores settings and options applied to every [UIImage] generated by an [ImageFactory]
 *
 * @property autoSize Whether the generated image should automatically have its width and height set to same value as the loaded texture
 * @property color The initial color the generated image should be set to
 * @property minFilter The texture min filter parameter OpenGL should use when rendering this image
 * @property magFilter The texture mag filter parameter OpenGL should use when rendering this image
 */
data class ImageGeneratorSettings(
    val autoSize: Boolean = true,
    val color: Color = Color.WHITE,
    val minFilter: UIImage.TextureScalingMode = UIImage.TextureScalingMode.NEAREST,
    val magFilter: UIImage.TextureScalingMode = UIImage.TextureScalingMode.NEAREST,
)

/**
 * An ImageFactory is a utility class for creating instances of a [UIImage]
 *
 * Each ImageFactory should only ever produce images for a single resource.
 *
 * Calls to [create] are non-blocking and automatically apply [settings] to the generated image.
 *
 */
abstract class ImageFactory(
    protected val settings: ImageGeneratorSettings = ImageGeneratorSettings()
) {
    /**
     * Produces a new [UIImage] and applies [settings]
     */
    fun create(): UIImage {
        return generate().apply {
            if (settings.autoSize) {
                supply(AutoImageSize(this))
            }
            textureMinFilter = settings.minFilter
            textureMagFilter = settings.magFilter
            setColor(settings.color)
        }
    }

    /**
     * Produces a new [UIImage]
     *
     * This method should be non-blocking. Any IO operation required to load
     * the texture of the image should happen on another thread.
     */
    protected abstract fun generate(): UIImage

    /**
     * @return a clone of this ImageFactory with the color setting changed
     */
    fun withColor(color: Color): ImageFactory {
        return DelegatedImageImageFactory(
            this,
            settings.copy(color = color)
        )
    }

    /**
     * @return a clone of this ImageFactory with the supplied settings
     */
    open fun withSettings(settings: ImageGeneratorSettings): ImageFactory {
        return DelegatedImageImageFactory(this, settings)
    }

}

/**
 * An ImageFactory that delegates the generation of images to the [innerSupplier] with the supplied [settings]
 */
private class DelegatedImageImageFactory(
    private val innerSupplier: ImageFactory,
    settings: ImageGeneratorSettings
) : ImageFactory(settings) {

    override fun generate(): UIImage {
        return innerSupplier.create()
    }

    override fun withSettings(settings: ImageGeneratorSettings): ImageFactory {
        return DelegatedImageImageFactory(innerSupplier, settings)
    }

}

/**
 * An ImageFactory that supplies the images through the provided [generator] function
 * Does not support caching.
 */
fun ImageFactory(
    generator: () -> UIImage,
): ImageFactory = object : ImageFactory() {
    override fun generate(): UIImage {
        return generator()
    }
}

